<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>모바일 갤러그</title>
<meta name="description" content="모바일 최적화 갤러그. 드래그=이동+사격, 10단계 보스, 무기 아이템(LASER/HOMING/BOMB 포함), 보스 페이즈 강화" />
<style>
  body { margin:0; background:#000; color:#fff; font-family:sans-serif; font-size:12px; touch-action:none; }
  canvas { display:block; width:100%; height:100dvh; background:#000; }
  .hud { position:fixed; top:5px; left:5px; font-size:11px; line-height:1.4; }
  .hud div { margin:2px 0; }
  .overlay { position:fixed; inset:0; display:flex; justify-content:center; align-items:center; background:rgba(0,0,0,0.75); color:#fff; text-align:center; }
  .overlay h1 { margin-bottom:10px; font-size:16px; }
  .overlay button { margin-top:8px; padding:6px 10px; font-size:14px; }
</style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud">
    <div>🏆 점수 <span id="score">0</span></div>
    <div>⭐ 최고 <span id="hiscore">0</span></div>
    <div>🗺️ 스테이지 <span id="stage">1</span>/10</div>
    <div>❤️ <span id="lives">3</span></div>
    <div>🔧 무기 <span id="weapon">NORMAL</span> <span id="weaponTime"></span></div>
    <div>💣 폭탄 <span id="bomb">0</span></div>
    <div id="bossHud" style="display:none">👑 보스 HP <span id="bossHp">0</span>/<span id="bossMax">0</span></div>
  </div>
  <div class="overlay" id="start">
    <div>
      <h1>👾 모바일 갤러그</h1>
      <p>드래그 = 이동 + 자동사격<br>더블탭 = 폭탄</p>
      <button onclick="startGame()">탭하여 시작</button>
    </div>
  </div>
  <div class="overlay" id="gameover" style="display:none">
    <div>
      <h1 id="overTitle">게임 오버</h1>
      <p>점수: <span id="finalScore"></span> | 최고: <span id="finalHi"></span></p>
      <button onclick="startGame()">다시 시작</button>
    </div>
  </div>
<script>
const canvas=document.getElementById("game"),ctx=canvas.getContext("2d");let W,H,DPR=1;function resize(){DPR=Math.min(window.devicePixelRatio||1,2);W=canvas.width=Math.floor(window.innerWidth*DPR);H=canvas.height=Math.floor(window.innerHeight*DPR);}resize();window.addEventListener("resize",resize);

// ---------------- Core State ----------------
let game,player,enemies=[],bullets=[],items=[],boss=null,lastTap=0,laserFlash=0,dragging=false;
// FX
let screenFlash=0; const shockwaves=[]; const particles=[]; const floatTexts=[]; // {x,y,ax,ay,life,col,size}

function startGame(){
  document.getElementById("start").style.display="none";
  document.getElementById("gameover").style.display="none";
  game={score:0,hiscore:Number(localStorage.getItem("galaga_hi")||0),stage:1,lives:3,over:false,inBoss:false};
  player={x:W/2,y:H-40*DPR,w:24*DPR,h:16*DPR,fireDelay:0.12,cooldown:0,weapon:"NORMAL",timer:0,bombs:1,inv:0};
  enemies=[]; bullets=[]; items=[]; boss=null; laserFlash=0; screenFlash=0; shockwaves.length=0; particles.length=0; floatTexts.length=0;
  buildWave(); updateHUD();
}

function updateHUD(){
  const $=id=>document.getElementById(id);
  $("score").textContent=game.score; $("hiscore").textContent=game.hiscore; $("stage").textContent=game.stage; $("lives").textContent=game.lives; $("weapon").textContent=player.weapon; $("weaponTime").textContent=player.timer>0?`(${Math.ceil(player.timer)}s)`:""; $("bomb").textContent=player.bombs;
  if(boss){ $("bossHud").style.display="block"; $("bossHp").textContent=Math.max(0,Math.floor(boss.hp)); $("bossMax").textContent=boss.maxHp; } else { $("bossHud").style.display="none"; }
}

// ---------------- Waves & Boss ----------------
function buildWave(){
  enemies=[]; let rows=4,cols=8,cellW=36*DPR,cellH=28*DPR;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) enemies.push({x:W/2-cols*cellW/2+c*cellW,y:40*DPR+r*cellH,w:24*DPR,h:16*DPR,alive:true,row:r});
}
function trySpawnBoss(){ if(game.inBoss||boss) return; if(enemies.every(e=>!e.alive)){ spawnBoss(); } }
function spawnBoss(){ let hp=180+game.stage*90; boss={x:W/2-60*DPR,y:40*DPR,w:120*DPR,h:80*DPR,hp,maxHp:hp,dir:1,angle:0,shot:0,phase:0}; game.inBoss=true; }

// Boss shooting with animated bullets (color shift)
function bossShoot(){ if(!boss) return; const s=game.stage; boss.angle+=0.3; const phaseBoost=(boss.hp/boss.maxHp<=0.5)?1.25:1; const speed=(220+s*18)*DPR*phaseBoost; const mode=((s+(phaseBoost>1?1:0))%4);
  const cx=boss.x+boss.w/2, cy=boss.y+boss.h/2;
  if(mode===0){ // ring
    const n=12+((s/2)|0)+(phaseBoost>1?6:0); for(let i=0;i<n;i++){ const th=i/n*Math.PI*2; bullets.push(makeBullet(cx,cy,Math.sin(th)*speed,Math.cos(th)*speed,'e', {hueBase:320+i*10})); }
  } else if(mode===1){ // spiral
    for(let k=0;k<5+(phaseBoost>1?2:0);k++){ const th=boss.angle+k*0.6; bullets.push(makeBullet(cx,cy,Math.sin(th)*speed,Math.cos(th)*speed,'e', {hueBase:200+k*20})); }
  } else if(mode===2){ // aimed burst
    const n=3+((s*0.3)|0)+(phaseBoost>1?2:0); for(let i=0;i<n;i++){ const off=-0.2+i/(n-1||1)*0.4; const v=aimVec(cx,cy,player.x,player.y,speed); bullets.push(makeBullet(cx,cy,v.vx+Math.sin(off)*80*DPR,v.vy+Math.cos(off)*60*DPR,'e',{hueBase:0+i*18})); }
  } else { // sweep
    for(let a=-0.5;a<=0.5;a+=phaseBoost>1?0.08:0.1){ const th=a+Math.sin(boss.angle*0.6)*0.45; bullets.push(makeBullet(cx,cy,Math.sin(th)*speed,Math.cos(th)*speed,'e',{hueBase:260+a*100})); }
  }
}

// ---------------- Items & Weapons ----------------
function dropItem(x,y){ if(Math.random()<0.2){ let types=["SPREAD","PIERCE","RAPID","LASER","HOMING","BOMB"]; let t=types[Math.random()*types.length|0]; items.push({x,y,w:14*DPR,h:14*DPR,vy:60*DPR,type:t}); } }
function grantItem(t){ if(t==="BOMB"){ player.bombs++; } else { player.weapon=t; player.timer=t==="LASER"?12:15; player.fireDelay=t==="RAPID"?0.06:0.12; } updateHUD(); popText(player.x,player.y-20*DPR,t==="BOMB"?"+BOMB":t,"#fff"); }

// ---------------- Bullets ----------------
function makeBullet(x,y,vx,vy,owner,extra={}){ return {x,y,w:4*DPR,h:10*DPR,vx,vy,owner:owner,homing:false,pierce:false,age:0,hueBase:extra.hueBase||0}; }
function fire(){ if(player.cooldown>0) return; const baseVy=-400*DPR; if(player.weapon==="LASER"){ // beam instant
    laserFlash=0.14; beamDamage();
  } else if(player.weapon==="HOMING"){ for(let k=-1;k<=1;k+=2) bullets.push({x:player.x+k*8*DPR,y:player.y,w:4*DPR,h:10*DPR,vx:0,vy:-280*DPR,owner:'p',homing:true,age:0}); }
  else if(player.weapon==="SPREAD"){ bullets.push(makeBullet(player.x,player.y, -120*DPR, baseVy*0.95,'p')); bullets.push(makeBullet(player.x,player.y, 0, baseVy,'p')); bullets.push(makeBullet(player.x,player.y, 120*DPR, baseVy*0.95,'p')); }
  else { bullets.push(makeBullet(player.x,player.y,0, baseVy,'p',{pierce:player.weapon==="PIERCE"})); }
  player.cooldown=player.fireDelay; }
function beamDamage(){ // apply damage line to boss/enemies + FX
  const x=player.x, y1=0, y2=player.y; // boss
  if(boss && x>boss.x && x<boss.x+boss.w && y1<boss.y+boss.h && y2>boss.y){ let dmg=30; boss.hp-=dmg; hitFX(x,boss.y+boss.h/2,true,dmg); if(boss.hp<=0){ killBoss(); } }
  enemies.forEach(e=>{ if(!e.alive) return; if(x>e.x && x<e.x+e.w && e.y<y2){ e.alive=false; game.score+=10; enemyExplode(e.x+e.w/2,e.y+e.h/2); dropItem(e.x+e.w/2,e.y+e.h/2); }});
}

// ---------------- Collisions ----------------
function rectHit(a,b){ return a.x-a.w/2 < b.x && a.x+a.w/2 > b.x-b.w && a.y-a.h/2 < b.y && a.y+a.h/2 > b.y-b.h; }

function updateBullets(dt){
  for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; b.age+=dt; // homing steer
    if(b.owner==='p' && b.homing){ const target = boss? {x:boss.x+boss.w/2,y:boss.y+boss.h/2} : nearestEnemy(b.x,b.y); if(target){ const spd=Math.hypot(b.vx,b.vy)||200*DPR; const v=aimVec(b.x,b.y,target.x,target.y,spd); const turn=6*dt; b.vx=b.vx*(1-turn)+v.vx*turn; b.vy=b.vy*(1-turn)+v.vy*turn; } }
    b.x+=b.vx*dt; b.y+=b.vy*dt;
    // lifetime / out of bounds
    if(b.y<-40*DPR || b.y>H+40*DPR || b.x<-40*DPR || b.x>W+40*DPR){ bullets.splice(i,1); continue; }
    // collisions
    if(b.owner==='p'){
      if(boss && boxOverlapPoint(boss,b.x,b.y)){ boss.hp -= 10; hitFX(b.x,b.y,true,10); if(boss.hp<=0){ killBoss(); } if(player.weapon!=="PIERCE") { bullets.splice(i,1); continue; } }
      for(const e of enemies){ if(!e.alive) continue; if(pointInRect(b.x,b.y,e)){ e.alive=false; game.score+=10; if(player.weapon!=="PIERCE") bullets.splice(i,1); enemyExplode(e.x+e.w/2,e.y+e.h/2); dropItem(e.x+e.w/2,e.y+e.h/2); break; }
      }
    }
  }
}
function pointInRect(x,y,r){ return x>r.x && x<r.x+r.w && y>r.y && y<r.y+r.h; }
function boxOverlapPoint(b,x,y){ return x>b.x && x<b.x+b.w && y>b.y && y<b.y+b.h; }
function nearestEnemy(x,y){ let best=null,bd=1e9; for(const e of enemies){ if(!e.alive) continue; const ex=e.x+e.w/2, ey=e.y+e.h/2; const d=Math.hypot(ex-x,ey-y); if(d<bd){bd=d; best={x:ex,y:ey};} } return best; }
function killBoss(){ game.score+=300+game.stage*50; enemyExplode(boss.x+boss.w/2,boss.y+boss.h/2, 40); boss=null; game.inBoss=false; nextStage(); }

// ---------------- FX Helpers ----------------
function popText(x,y,txt,col="#ff0",size=10*DPR){ floatTexts.push({x,y,txt,life:1,col,size}); }
function enemyExplode(x,y,count=24){ // particles burst
  for(let i=0;i<count;i++){ const ang=Math.random()*Math.PI*2; const sp= (40+Math.random()*120)*DPR; particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:0.9+Math.random()*0.4,col:`hsl(${(Math.random()*60+10)|0} 90% 60%)`,size:(1+Math.random()*2)*DPR}); }
}
function hitFX(x,y,isBoss=false,dmg=0){ for(let i=0;i<12;i++){ const ang=Math.random()*Math.PI*2; const sp=(60+Math.random()*160)*DPR; particles.push({x,y,vx:Math.cos(ang)*sp,vy:Math.sin(ang)*sp,life:0.3+Math.random()*0.4,col:isBoss?"#ff99cc":"#ffd166",size:(1+Math.random()*2)*DPR}); } if(dmg) popText(x,y-10*DPR,`-${dmg}`,"#ff7ab6",12*DPR); updateHUD(); }
function addShockwave(x,y){ shockwaves.push({x,y,r:0,life:0.5}); }

// ---------------- Bomb ----------------
function detonateBomb(){ if(player.bombs<=0) return; player.bombs--; screenFlash=0.5; addShockwave(player.x,player.y-10*DPR); // clear enemy bullets
  for(let i=bullets.length-1;i>=0;i--){ if(bullets[i].owner!=='p') bullets.splice(i,1); }
  // boss damage small percent
  if(boss){ const dealt=Math.floor(boss.maxHp*0.08); boss.hp=Math.max(0,boss.hp-dealt); hitFX(boss.x+boss.w/2,boss.y+boss.h/2,true,dealt); if(boss.hp<=0) killBoss(); }
  // particles burst across screen
  for(let k=0;k<60;k++){ particles.push({x:Math.random()*W,y:Math.random()*H*0.6,vx:(Math.random()-0.5)*80*DPR,vy:(Math.random()-0.5)*80*DPR,life:0.6+Math.random()*0.6,col:"rgba(255,255,255,0.8)",size:(1+Math.random()*2)*DPR}); }
  updateHUD();
}

// ---------------- Input ----------------
canvas.addEventListener("pointerdown",e=>{ const now=performance.now(); if(now-lastTap<280){ detonateBomb(); lastTap=0; return; } lastTap=now; dragging=true; });
window.addEventListener("pointerup",()=>dragging=false);
window.addEventListener("pointermove",e=>{ if(!dragging) return; const x=e.clientX*DPR; player.x=Math.max(20*DPR,Math.min(W-20*DPR,x)); });

// ---------------- Game Flow ----------------
function nextStage(){ game.stage++; if(game.stage>10){ victory(); return; } buildWave(); if(Math.random()<0.3) player.bombs++; updateHUD(); }
function victory(){ game.over=true; document.getElementById("overTitle").textContent="모든 스테이지 클리어!"; gameover(); }
function gameover(){ game.over=true; document.getElementById("finalScore").textContent=game.score; if(game.score>game.hiscore){ game.hiscore=game.score; localStorage.setItem("galaga_hi",game.hiscore);} document.getElementById("finalHi").textContent=game.hiscore; document.getElementById("gameover").style.display="flex"; }

// ---------------- Math Helpers ----------------
function aimVec(sx,sy,tx,ty,spd){ const dx=tx-sx, dy=ty-sy; const d=Math.hypot(dx,dy)||1; return {vx:dx/d*spd, vy:dy/d*spd}; }

// ---------------- Render ----------------
function draw(){ ctx.clearRect(0,0,W,H);
  // star field (simple)
  ctx.fillStyle="#02040a"; ctx.fillRect(0,0,W,H);
  // player
  if(!(player.inv>0 && ((performance.now()/60|0)%2===0))){ ctx.fillStyle="#7fd8ff"; ctx.fillRect(player.x-player.w/2,player.y-player.h/2,player.w,player.h); }
  // enemies
  ctx.fillStyle="#8ef06a"; enemies.forEach(e=>{ if(e.alive) ctx.fillRect(e.x, e.y, e.w, e.h); });
  // boss
  if(boss){ ctx.fillStyle="#ff4b6e"; ctx.fillRect(boss.x,boss.y,boss.w,boss.h); }
  // bullets (animated color for enemy)
  for(const b of bullets){ if(b.owner==='e'){ const hue=(b.hueBase + b.age*240)%360; ctx.fillStyle=`hsl(${hue} 90% 60%)`; } else ctx.fillStyle="#ffd166"; ctx.fillRect(b.x-2*DPR,b.y-5*DPR,4*DPR,10*DPR); }
  // items
  for(const it of items){ ctx.fillStyle='rgba(255,255,255,.15)'; ctx.beginPath(); ctx.arc(it.x,it.y,10*DPR,0,Math.PI*2); ctx.fill(); ctx.fillStyle = it.type==='SPREAD' ? '#ffd166' : it.type==='PIERCE' ? '#9cff7a' : it.type==='RAPID' ? '#67b8ff' : it.type==='LASER' ? '#ff9bd7' : it.type==='HOMING' ? '#b4ff9b' : '#ffffff'; ctx.beginPath(); ctx.arc(it.x,it.y,7*DPR,0,Math.PI*2); ctx.fill(); }
  // laser beam
  if(laserFlash>0){ const x=player.x, y0=0, y1=player.y; const g=ctx.createLinearGradient(x,y0,x,y1); g.addColorStop(0,'rgba(255,255,255,0)'); g.addColorStop(0.2,'rgba(255,160,240,0.6)'); g.addColorStop(1,'rgba(255,80,200,1)'); ctx.strokeStyle=g; ctx.lineWidth=6*DPR; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); ctx.globalCompositeOperation='lighter'; ctx.lineWidth=2*DPR; ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y1); ctx.stroke(); ctx.globalCompositeOperation='source-over'; }
  // shockwaves
  for(const sw of shockwaves){ const a=Math.max(0, sw.life*2-0.2); ctx.strokeStyle=`rgba(255,255,255,${a})`; ctx.lineWidth=3*DPR; ctx.beginPath(); ctx.arc(sw.x,sw.y, sw.r, 0, Math.PI*2); ctx.stroke(); }
  // particles
  for(const p of particles){ ctx.fillStyle=p.col; ctx.fillRect(p.x, p.y, p.size, p.size); }
  // floating texts
  for(const ft of floatTexts){ ctx.fillStyle=ft.col; ctx.font = `${ft.size}px sans-serif`; ctx.textAlign='center'; ctx.fillText(ft.txt, ft.x, ft.y); }
  // screen flash overlay
  if(screenFlash>0){ ctx.fillStyle=`rgba(255,255,255,${Math.min(0.6,screenFlash)})`; ctx.fillRect(0,0,W,H); }
}

// ---------------- Main Loop ----------------
let last=0; function loop(ts){ if(!last) last=ts; const dt=Math.min(0.033,(ts-last)/1000); last=ts; if(!game||game.over){ draw(); requestAnimationFrame(loop); return; }
  if(dragging) fire(); if(player.cooldown>0) player.cooldown-=dt; if(player.timer>0){ player.timer-=dt; if(player.timer<=0){ player.weapon='NORMAL'; } }
  // enemies step (simple sway)
  let aliveExist=false; for(const e of enemies){ if(!e.alive) continue; aliveExist=true; e.x += Math.sin(ts*0.001 + e.row)*10*DPR*dt; }
  if(!aliveExist) trySpawnBoss();
  // boss move & shoot
  if(boss){ boss.phase = boss.hp/boss.maxHp<=0.5?1:0; boss.x += (80*DPR*(boss.phase?1.2:1)) * boss.dir * dt; if(boss.x<10*DPR || boss.x+boss.w>W-10*DPR){ boss.dir*=-1; boss.y+=8*DPR; }
    boss.shot += dt; const rate=(0.8 - game.stage*0.05)/(boss.phase?1.25:1); if(boss.shot>Math.max(0.22,rate)){ boss.shot=0; bossShoot(); }
  }
  // bullets
  updateBullets(dt);
  // items fall & pickup
  for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.y+=it.vy*dt; if(it.y>H+20*DPR){ items.splice(i,1); continue; } const hit = Math.abs(it.x-player.x)<(player.w*0.6) && Math.abs(it.y-player.y)<(player.h*0.6); if(hit){ grantItem(it.type); items.splice(i,1); }}
  // FX updates
  for(let i=shockwaves.length-1;i>=0;i--){ const sw=shockwaves[i]; sw.r += 900*DPR*dt; sw.life-=dt; if(sw.life<=0) shockwaves.splice(i,1); }
  for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx*=0.98; p.vy*=0.98; p.life-=dt; if(p.life<=0) particles.splice(i,1); }
  for(let i=floatTexts.length-1;i>=0;i--){ const f=floatTexts[i]; f.y-=40*dt*DPR; f.life-=dt; if(f.life<=0) floatTexts.splice(i,1); }
  if(laserFlash>0) laserFlash-=dt; if(screenFlash>0) screenFlash-=dt*1.8;

  updateHUD(); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>