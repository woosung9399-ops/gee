<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>모바일 갤러그</title>
<meta name="description" content="모바일 최적화 한 파일 갤러그. 드래그=이동+사격, 1열 작은 UI, 10단계 보스. 하단 버튼 제거. 보스/적 탄막 패턴 + 무기 아이템" />
<style>
  :root{ --bg:#0b0f19; --panel:#12182A; --accent:#67b8ff; --accent2:#ffd166; --danger:#ff6b6b; --text:#e9ecff; --muted:#9aa5c4; --border:#223057; --shadow:rgba(0,0,0,.35); }
  *{box-sizing:border-box}
  html,body{height:100%;}
  body{margin:0; background:radial-gradient(1200px 600px at 50% -10%, #0f1530 0%, #0b0f19 45%, #090d16 100%); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Pretendard","Segoe UI", Roboto, Helvetica, Arial, sans-serif; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; touch-action:none; overscroll-behavior:none; font-size:12px}

  /* === Added Global/Header Styles === */
  header{position:fixed; top:0; left:0; right:0; z-index:50; padding:calc(env(safe-area-inset-top, 0px) + 6px) 8px 6px 8px; display:flex; justify-content:space-between; align-items:center; gap:8px; pointer-events:none}
  header .logo{pointer-events:auto; display:inline-flex; align-items:center; gap:6px; background:rgba(18,24,42,.7); border:1px solid var(--border); border-radius:10px; padding:6px 10px; box-shadow:0 6px 20px var(--shadow); cursor:pointer}
  header .logo .word{font-weight:800; letter-spacing:.3px}
  header .logo .i{position:relative; display:inline-block}
  header .logo .dot{position:absolute; width:4px; height:4px; right:-2px; bottom:0; border-radius:50%; background:var(--accent)}
  header .hud{pointer-events:auto}
  .btn{background:rgba(18,24,42,.7); border:1px solid var(--border); border-radius:10px; padding:6px 10px; box-shadow:0 6px 20px var(--shadow); color:var(--text); font-weight:700; cursor:pointer}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  .wrap{position:relative; width:100%; height:100dvh;}
  canvas{position:fixed; inset:0; width:100%; height:100dvh; display:block;}

  /* HUD: 작은 글씨 + 1열 */
  .hud-layer{position:fixed; inset:0; pointer-events:none;}
  .topbar{position:absolute; top:calc(env(safe-area-inset-top, 6px) + 48px); left:8px; right:8px; display:flex; flex-direction:column; align-items:flex-start; gap:6px; pointer-events:none;}
  .pill{background:rgba(18,24,42,.65); border:1px solid var(--border); border-radius:10px; padding:6px 8px; box-shadow:0 6px 20px var(--shadow); display:inline-flex; align-items:center; gap:6px; font-weight:600; font-size:11px; line-height:1}
  .lives{display:inline-flex; gap:4px}
  .ship{width:14px; height:10px; background:linear-gradient(#9be7ff,#67b8ff); clip-path:polygon(50% 0%, 65% 30%, 100% 35%, 100% 65%, 65% 70%, 50% 100%, 35% 70%, 0% 65%, 0% 35%, 35% 30%); filter:drop-shadow(0 0 4px rgba(103,184,255,.5));}
  .iconbtn{background:rgba(18,24,42,.65); border:1px solid var(--border); border-radius:8px; padding:6px 8px; font-size:12px; box-shadow:0 6px 20px var(--shadow); cursor:pointer; user-select:none; pointer-events:auto;}
  .row1col{display:flex; flex-direction:column; gap:6px; pointer-events:auto}

  /* Overlays (작게) */
  .overlay{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;}
  .card{background:rgba(10,14,26,.85); border:1px solid var(--border); border-radius:16px; padding:16px; width:min(520px, calc(100% - 24px)); box-shadow:0 20px 60px var(--shadow); text-align:center}
  .card h1{margin:0 0 6px; font-size:16px}
  .card p{margin:6px 0; color:var(--muted); font-size:12px}
  .card .row{display:flex; gap:6px; justify-content:center; margin-top:8px; flex-wrap:wrap}
  .card .chip{background:rgba(255,255,255,.06); border:1px solid var(--border); border-radius:999px; padding:6px 8px; font-weight:600; font-size:11px}
  .startbtn{margin-top:10px; background:rgba(18,24,42,.75); border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-weight:700}
</style>
</head>
<body>

  <!-- === Added Header (extra, not replacing HUD) === -->
  <header>
    <div id="homeLogo" class="logo" role="button" tabindex="0" title="초기 화면으로 이동">
      <span class="word">mult<span class="i">ı<span class="dot" aria-hidden="true"></span></span>campus</span>
      <span class="sr-only">multicampus</span>
    </div>
    <div class="hud" aria-live="polite">
      <button id="pauseBtnTop" class="btn">⏸️ Pause</button>
    </div>
  </header>

  <div class="wrap">
    <canvas id="game"></canvas>

    <div class="hud-layer">
      <div class="topbar">
        <div class="row1col">
          <div class="pill">🏆 점수 <span id="score" style="margin-left:6px">0</span></div>
          <div class="pill">🗺️ 스테이지 <span id="stage" style="margin-left:6px">1</span> / <span id="maxstage">10</span></div>
          <div class="pill" id="hiscorepill" title="최고 점수">⭐ 최고 <span id="hiscore" style="margin-left:6px">0</span></div>
          <div class="pill lives" id="lives"></div>
          <div class="pill" id="weaponHud">🔧 무기 <span id="weaponName">NORMAL</span> <span id="weaponTime"></span></div>
          <div class="pill" id="bossHud" style="display:none">👑 보스 HP <span id="bossHp">0</span>/<span id="bossMax">0</span></div>
          <div class="iconbtn" id="pauseBtn">⏸️ 일시정지</div>
          <div class="iconbtn" id="muteBtn">🔇 음소거</div>
        </div>
      </div>
    </div>

    <div class="overlay" id="startOverlay">
      <div class="card">
        <h1>👾 모바일 갤러그</h1>
        <p>하단 버튼 없이, 화면을 <b>드래그하면 이동 + 자동사격</b> 됩니다.<br/>보스/적 탄막 패턴 강화 + <b>무기 아이템</b> 추가!</p>
        <div class="row">
          <div class="chip">📱 모바일 최적화</div>
          <div class="chip">🔥 드래그 연사</div>
          <div class="chip">👑 보스: 링/스파이럴/조준/스윕</div>
          <div class="chip">🧰 아이템: SPREAD/PIERCE/RAPID</div>
        </div>
        <div class="startbtn" id="startBtn">탭하여 시작</div>
      </div>
    </div>

    <div class="overlay" id="gameOverOverlay" style="display:none">
      <div class="card">
        <h1 id="overTitle">게임 오버 💫</h1>
        <p>점수: <b id="finalScore">0</b> | 최고: <b id="finalHi">0</b></p>
        <div class="startbtn" id="retryBtn">다시 시작</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const $ = id => document.getElementById(id);

  // Header elements (new)
  const headerPause = $('pauseBtnTop');
  const homeLogo = $('homeLogo');

  // HUD elements
  const elScore = $('score');
  const elStage = $('stage');
  const elMaxStage = $('maxstage');
  const elLives = $('lives');
  const elHi = $('hiscore');
  const elPause = $('pauseBtn');
  const elMute = $('muteBtn');
  const startOverlay = $('startOverlay');
  const gameOverOverlay = $('gameOverOverlay');
  const overTitle = $('overTitle');
  const finalScore = $('finalScore');
  const finalHi = $('finalHi');
  const startBtn = $('startBtn');
  const retryBtn = $('retryBtn');
  const bossHud = $('bossHud');
  const bossHpText = $('bossHp');
  const bossMaxText = $('bossMax');
  const weaponHud = $('weaponHud');
  const weaponName = $('weaponName');
  const weaponTime = $('weaponTime');

  // Device Pixel Ratio handling
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  const maxStage = 10; elMaxStage.textContent = maxStage;

  function resize() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    playW = canvas.width; playH = canvas.height; // 전체 화면 사용
    player.y = playH - 36 * DPR;
    player.x = clamp(player.x, 16 * DPR, playW - 16 * DPR);
  }

  // Game state
  const game = { started:false, paused:false, muted:true, over:false, score:0, stage:1, lives:3, hi:Number(localStorage.getItem('galaga_hi')||0), inBoss:false, victory:false };
  elHi.textContent = game.hi;

  // Player & Weapon
  const player = { x: 200, y: 0, w: 26, h: 18, speed: 280, cooldown:0, baseDelay:0.11, fireDelay:0.11, invul:0, blink:0 };
  const weapon = { type:'NORMAL', timer:0 };

  // Entities
  const bullets = []; // {x,y,vx,vy,owner:'player'|'enemy'|'boss', w,h, pierce?:bool, zig?, wave?, grav?}
  let enemies = [];   // {x,y,w,h,alive,row,col}
  let enemyBox = {x:0,y:0,w:0,h:0, dir:1, speed:40, step:16};
  let lastEnemyShot = 0; let boss = null; // {x,y,w,h,hp,maxHp,dir,speed,phase,shotTimer,angle}
  const items = []; // {x,y,w,h,vy,type}

  // Dimensions
  let playW = 0, playH = 0;

  // Input state
  const keys = {left:false, right:false, fire:false};
  let dragActive = false;

  // Audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext; let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) try{ audioCtx = new AudioCtx(); }catch(e){} }
  function beep(freq=420, dur=0.05, vol=0.05){ if(game.muted) return; ensureAudio(); if(!audioCtx) return; const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(audioCtx.destination); o.start(); o.stop(t+dur); }

  // Helpers
  const rand = (a,b)=>Math.random()*(b-a)+a; const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  const aimVec = (sx,sy, tx,ty, spd)=>{ const dx=tx-sx, dy=ty-sy; const d=Math.hypot(dx,dy)||1; return {vx:dx/d*spd, vy:dy/d*spd}; };

  function resetHUD(){ elScore.textContent = game.score; elStage.textContent = game.stage; refreshLives(); updateBossHud(); updateWeaponHud(); updatePauseButtons(); }
  function refreshLives(){ elLives.innerHTML = ''; for(let i=0;i<game.lives;i++){ const d=document.createElement('div'); d.className='ship'; elLives.appendChild(d);} }
  function updateBossHud(){ if(game.inBoss && boss){ bossHud.style.display='inline-flex'; bossHpText.textContent = Math.max(0, Math.ceil(boss.hp)); bossMaxText.textContent = boss.maxHp; } else { bossHud.style.display='none'; } }
  function updateWeaponHud(){ weaponName.textContent = weapon.type; weaponTime.textContent = weapon.timer>0 ? `(${Math.ceil(weapon.timer)}s)` : ''; }
  function updatePauseButtons(){ if(elPause) elPause.textContent = game.paused? '▶️ 재개' : '⏸️ 일시정지'; if(headerPause) headerPause.textContent = game.paused? '▶️ Resume' : '⏸️ Pause'; }

  function buildWave(stage=1){
    enemies.length = 0; boss = null; game.inBoss = false;
    const rows = clamp(3 + Math.floor(stage*0.6), 3, 7);
    const cols = clamp(6 + Math.floor(stage/2), 6, 12);
    const cellW = 34 * DPR, cellH = 28 * DPR; const startX = (playW - cols*cellW) * 0.5; const startY = 26 * DPR;
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) enemies.push({ x: startX + c*cellW, y: startY + r*cellH, w: 24*DPR, h: 18*DPR, alive:true, row:r, col:c });
    enemyBox = { x:startX, y:startY, w: cols*cellW, h: rows*cellH, dir:1, speed: (40 + stage*14) * DPR, step: 16*DPR };
  }

  function spawnBoss(stage){
    // HP: 1스테이지 400, 스테이지마다 +150
    const hp = 400 + (stage - 1) * 150;
    const size = Math.min(120 + stage*10, 200) * DPR;
    const speed = (40 + stage*10) * DPR; // 이동속도 강화
    boss = { x: playW*0.5 - size*0.5, y: 36*DPR, w: size, h: size*0.6, hp, maxHp: hp, dir: 1, speed, phase: 0, shotTimer: 0, angle: 0 };
    game.inBoss = true; updateBossHud(); beep(200,0.25,0.07); beep(160,0.25,0.06);
  }

  function startGame(){ game.started = true; game.paused=false; game.over=false; game.victory=false; game.score=0; game.stage=1; game.lives=3; player.invul=1.3; player.blink=0; weapon.type='NORMAL'; weapon.timer=0; player.fireDelay = player.baseDelay; resetHUD(); buildWave(game.stage); player.x = playW * 0.5; player.y = playH - 36 * DPR; bullets.length = 0; items.length = 0; hideOverlay(startOverlay); }
  function nextStage(){ if(game.stage >= maxStage){ victory(); return; } game.stage++; elStage.textContent = game.stage; game.inBoss=false; boss=null; updateBossHud(); buildWave(game.stage); player.invul=1.0; player.blink=0; }
  function victory(){ game.victory = true; game.over=true; game.paused=true; overTitle.textContent = '모든 난이도 클리어! 🏆'; finalScore.textContent = game.score; if(game.score > game.hi){ game.hi = game.score; localStorage.setItem('galaga_hi', String(game.hi)); } finalHi.textContent = game.hi; showOverlay(gameOverOverlay); }
  function gameOver(){ game.over = true; game.paused = true; overTitle.textContent = '게임 오버 💫'; finalScore.textContent = game.score; if(game.score > game.hi){ game.hi = game.score; localStorage.setItem('galaga_hi', String(game.hi)); } finalHi.textContent = game.hi; showOverlay(gameOverOverlay); }
  function showOverlay(el){ el.style.display='flex'; }
  function hideOverlay(el){ el.style.display='none'; }

  // --- Weapons & Items ---
  function grantWeapon(type){
    weapon.type = type; weapon.timer = 15; // 15초 지속
    if(type==='RAPID') player.fireDelay = Math.max(0.05, player.baseDelay*0.6); else player.fireDelay = player.baseDelay;
    updateWeaponHud(); beep(900,0.08,0.05); beep(600,0.08,0.05);
  }
  function maybeDropItem(x,y){
    const chance = 0.12; // 12% 드랍
    if(Math.random() < chance){
      const types = ['SPREAD','PIERCE','RAPID'];
      const t = types[(Math.random()*types.length)|0];
      items.push({x:x, y:y, w:14*DPR, h:14*DPR, vy: 120*DPR, type:t});
    }
  }

  function attemptShoot(){
    if(player.cooldown>0) return;
    const baseVy = -540*DPR;
    const bw = 3*DPR, bh = 10*DPR;
    const make = (offX, offVyMul=1)=> bullets.push({x:player.x + offX - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:0, vy:baseVy*offVyMul, owner:'player', pierce:(weapon.type==='PIERCE')});
    if(weapon.type==='SPREAD'){
      bullets.push({x:player.x - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:-120*DPR, vy:baseVy*0.95, owner:'player', pierce:false});
      make(0,1);
      bullets.push({x:player.x - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:120*DPR, vy:baseVy*0.95, owner:'player', pierce:false});
    } else if(weapon.type==='RAPID'){ make(0,1); }
      else if(weapon.type==='PIERCE'){ make(0,1);} else { make(0,1); }
    player.cooldown = player.fireDelay; beep(880,0.04,0.04);
  }

  // Enemy shots (아래로만 떨어지는 탄 + 다양한 패턴)
  function enemyShoot(from){
    const s = game.stage;
    const base = (230 + s*38) * DPR; // 난이도별 낙하 속도
    const pattern = Math.floor(Math.random()*5); // 0~4 패턴
    const originX = from.x + from.w*0.5, originY = from.y + from.h;

    if(pattern===0){
      // 0) 스트레이트 레인: 직하
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base, owner:'enemy'});
    } else if(pattern===1){
      // 1) 드리프트: 서서히 좌/우로 기울며 하강
      const drift = (Math.random()<0.5?-1:1) * (40 + s*4) * DPR;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:drift*0.3, vy:base, owner:'enemy'});
    } else if(pattern===2){
      // 2) 지그재그: 좌우로 흔들리며 하강
      const vx = (Math.random()<0.5?-1:1) * (80 + s*6) * DPR;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx, vy:base*0.9, owner:'enemy', zig:1});
    } else if(pattern===3){
      // 3) 웨이브: 사인파로 좌우 이동하며 하강
      const amp = (60 + s*6) * DPR; // 좌우 속도 진폭(px/s)
      const freq = 1.6 + s*0.06;   // 진동수(Hz 유사)
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base*0.92, owner:'enemy', wave:{amp, freq, t:0}});
    } else {
      // 4) 가속 낙하: 떨어지면서 점점 빨라짐
      const grav = (200 + s*30) * DPR; // 가속도(px/s^2)
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base*0.75, owner:'enemy', grav});
    }
    beep(260,0.06,0.035);
  }

  // Boss patterns (강화 유지)
  function bossShoot(){
    if(!boss) return;
    const s = game.stage;
    const cx = boss.x + boss.w*0.5; const cy = boss.y + boss.h*0.5;
    boss.angle += 0.25 + s*0.03; // 회전 속도 강화
    const pick = (s % 4);
    const speedBase = (250 + s*45) * DPR; // 탄속 강화
    switch(pick){
      case 1: // spiral
        for(let k=0;k<5;k++){ const ang = (boss.angle + k*0.5); const vx = Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase; bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'}); }
        break;
      case 2: // 조준 벌스트
        for(let i=0;i<4+Math.floor(s*0.4);i++){ const spread = (-0.2 + (i/Math.max(1,3+Math.floor(s*0.4)))*0.4); const V = aimVec(cx, cy, player.x, player.y, speedBase); const vx = V.vx + Math.sin(spread)*100*DPR; const vy = V.vy + Math.cos(spread)*60*DPR; bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});} 
        break;
      case 3: // 스윕 아크
        for(let a=-0.6;a<=0.6;a+=0.1){ const ang = a + Math.sin(boss.angle*0.6)*0.5; const vx=Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase; bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});} 
        break;
      default: // 링
        const n = 12 + Math.floor(s*0.6); for(let i=0;i<n;i++){ const ang = (i/n)*Math.PI*2; const vx=Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase; bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});} 
    }
    beep(180,0.08,0.05);
  }

  function killEnemy(e, worldX, worldY){ e.alive=false; game.score += 10 + Math.floor((8 - e.row) * 0.5); elScore.textContent = game.score; maybeDropItem(worldX, worldY); beep(520,0.05,0.05); }
  function hitPlayer(){ if(player.invul>0) return; game.lives--; refreshLives(); if(game.lives<=0){ gameOver(); return; } player.invul = 1.6; player.blink = 0; beep(120,0.18,0.04); for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if(b.owner!=='player' && b.y>player.y-60*DPR) bullets.splice(i,1); } }

  // Main loop
  let last = 0; function loop(ts){ if(!last) last = ts; const dt = Math.min(0.033, (ts - last)/1000); last = ts; if(game.started && !game.paused){ update(dt); render(); } else { render(); } requestAnimationFrame(loop); }

  function update(dt){
    // weapon timer
    if(weapon.timer>0){ weapon.timer -= dt; if(weapon.timer<=0){ weapon.timer=0; weapon.type='NORMAL'; player.fireDelay=player.baseDelay; } updateWeaponHud(); }

    // player movement
    let dir = 0; if(keys.left) dir -= 1; if(keys.right) dir += 1; player.x += dir * player.speed * DPR * dt; player.x = clamp(player.x, 14*DPR, playW - 14*DPR);

    // firing & states
    if(keys.fire) attemptShoot(); if(player.cooldown>0) player.cooldown -= dt; if(player.invul>0){ player.invul -= dt; player.blink += dt*10; }

    // boss / wave
    if(game.inBoss && boss){
      boss.x += boss.speed * boss.dir * dt;
      if(boss.x < 8*DPR || boss.x + boss.w > playW - 8*DPR){ boss.dir *= -1; boss.y += 8*DPR; boss.speed *= 1.01; }
      boss.shotTimer += dt; const baseInt = Math.max(0.18, 0.9 - game.stage*0.07); // 더 자주 발사
      if(boss.shotTimer > baseInt){ boss.shotTimer = 0; bossShoot(); }
    } else {
      if(enemies.some(e=>e.alive)){
        enemyBox.x += enemyBox.speed * enemyBox.dir * dt;
        const alive = enemies.filter(e=>e.alive);
        let minX = Infinity, maxX = -Infinity, maxY = -Infinity; const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0;
        for(const e of alive){ const ex = e.x + (enemyBox.x - baseX); const ey = e.y + (enemyBox.y - baseY); minX = Math.min(minX, ex); maxX = Math.max(maxX, ex + e.w); maxY = Math.max(maxY, ey + e.h); }
        if(minX < 8*DPR || maxX > playW - 8*DPR){ enemyBox.dir *= -1; enemyBox.y += enemyBox.step; enemyBox.speed *= 1.02; }
        if(maxY > player.y - 10*DPR){ hitPlayer(); enemyBox.y -= 24*DPR; }
        lastEnemyShot += dt; const interval = Math.max(0.33, 1.0 - game.stage*0.06);
        if(lastEnemyShot > interval){ lastEnemyShot = 0; const bottomers = alive.filter(e=> !alive.some(o=>o.col===e.col && o.row>e.row)); if(bottomers.length){ const shooter = bottomers[(Math.random()*bottomers.length)|0]; const baseX2 = enemies[0] ? enemies[0].x : 0; const baseY2 = enemies[0] ? enemies[0].y : 0; enemyShoot({x: shooter.x + (enemyBox.x - baseX2), y: shooter.y + (enemyBox.y - baseY2), w: shooter.w, h: shooter.h}); } }
      } else { if(!game.inBoss && !boss){ spawnBoss(game.stage); } }
    }

    // bullets update
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      // 적 탄의 좌우 변형 처리 + 하강 유지
      if(b.owner==='enemy'){
        if(b.zig){ b.vx += (Math.random()<0.5?-1:1)*10*DPR*dt; }
        if(b.wave){ b.wave.t += dt; b.vx = Math.sin(b.wave.t * b.wave.freq) * b.wave.amp; }
        if(b.grav){ b.vy += b.grav * dt; }
        if(b.vy < 0) b.vy = Math.abs(b.vy);
      }
      b.x += b.vx*dt; b.y += b.vy*dt;
      if(b.y < -60*DPR || b.y > playH + 60*DPR || b.x < -60*DPR || b.x > playW + 60*DPR) bullets.splice(i,1);
    }

    // items fall
    for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.y += it.vy*dt; if(it.y>playH+20*DPR){ items.splice(i,1); continue; } const P={x:player.x - player.w*0.5, y:player.y - player.h*0.5, w:player.w, h:player.h}; if(aabb(it,P)){ grantWeapon(it.type); items.splice(i,1); }}

    // collisions: player bullets vs enemies/boss
    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if(b.owner!=='player') continue; let removed=false; if(game.inBoss && boss){ const B = {x:boss.x, y:boss.y, w:boss.w, h:boss.h}; if(aabb(b,B)){ if(!b.pierce){ bullets.splice(i,1); removed=true; } boss.hp -= 8 + Math.floor(game.stage*0.5); updateBossHud(); beep(380,0.05,0.04); if(boss.hp<=0){ game.score += 250 + game.stage*60; elScore.textContent = game.score; boss=null; game.inBoss=false; updateBossHud(); nextStage(); } }} if(removed) continue; for(let j=0;j<enemies.length;j++){ const e=enemies[j]; if(!e.alive) continue; const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0; const ex = e.x + (enemyBox.x - baseX); const ey = e.y + (enemyBox.y - baseY); const E = {x:ex,y:ey,w:e.w,h:e.h}; if(aabb(b,E)){ if(!b.pierce){ bullets.splice(i,1); removed=true; } killEnemy(e, ex+e.w*0.5, ey+e.h*0.5); break; } }
    }

    // collisions: enemy/boss bullets vs player
    const P = {x:player.x - player.w*0.5, y:player.y - player.h*0.5, w:player.w, h:player.h};
    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if(b.owner!=='player' && aabb(b,P)){ bullets.splice(i,1); hitPlayer(); } }
  }

  function render(){ ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height); drawStars(); if(!game.over){ if(!(player.invul>0 && Math.floor(player.blink)%2===0)){ drawShip(player.x, player.y, player.w, player.h); } } for(const e of enemies){ if(!e.alive) continue; const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0; drawEnemy(e.x + (enemyBox.x - baseX), e.y + (enemyBox.y - baseY), e.w, e.h, e.row); } if(game.inBoss && boss){ drawBoss(boss); } for(const b of bullets){ drawBullet(b); } for(const it of items){ drawItem(it); } ctx.restore(); }

  // Visuals
  const starField = new Array(120).fill(0).map(()=>({x:Math.random(), y:Math.random(), z:rand(0.2,1)}));
  function drawStars(){ const w=canvas.width, h=canvas.height; for(const s of starField){ s.y += 0.06 * s.z; if(s.y>1) s.y -= 1; const x=s.x*w, y=s.y*h; const r = (0.6 + 1.4*s.z) * DPR; ctx.fillStyle=`rgba(255,255,255,${0.33 + 0.42*s.z})`; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  }
  function drawShip(cx, cy, w, h){ ctx.save(); ctx.translate(cx, cy); const g = ctx.createLinearGradient(0,-h/2, 0, h/2); g.addColorStop(0,'#a8ecff'); g.addColorStop(1,'#67b8ff'); ctx.fillStyle = g; ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.lineTo(w*0.35, -h*0.1); ctx.lineTo(w*0.5, h*0.05); ctx.lineTo(w*0.5, h*0.35); ctx.lineTo(0, h/2); ctx.lineTo(-w*0.5, h*0.35); ctx.lineTo(-w*0.5, h*0.05); ctx.lineTo(-w*0.35, -h*0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#e6f7ff'; ctx.fillRect(-w*0.15, -h*0.15, w*0.3, h*0.18); ctx.restore(); }
  function drawEnemy(x,y,w,h,row){ ctx.save(); ctx.translate(x+w/2, y+h/2); const hues = [200, 270, 130, 10, 320, 40, 160, 220]; const hue = hues[row % hues.length]; ctx.fillStyle = `hsl(${hue} 80% 60%)`; ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.moveTo(0, -h*0.45); ctx.lineTo(w*0.5, -h*0.15); ctx.lineTo(w*0.48, h*0.15); ctx.lineTo(0, h*0.45); ctx.lineTo(-w*0.48, h*0.15); ctx.lineTo(-w*0.5, -h*0.15); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(0,0, h*0.18, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0, h*0.09, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawBoss(b){ ctx.save(); ctx.translate(b.x + b.w/2, b.y + b.h/2); const hue = 30 + game.stage*30; ctx.fillStyle = `hsl(${hue} 85% 55%)`; ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.lineWidth=2*DPR; const w=b.w, h=b.h; ctx.beginPath(); ctx.moveTo(0,-h*0.5); ctx.quadraticCurveTo(w*0.45,-h*0.2, w*0.5, 0); ctx.quadraticCurveTo(w*0.45,h*0.2, 0, h*0.5); ctx.quadraticCurveTo(-w*0.45,h*0.2, -w*0.5, 0); ctx.quadraticCurveTo(-w*0.45,-h*0.2, 0,-h*0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0, Math.min(w,h)*0.12, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0, Math.min(w,h)*0.06, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawBullet(b){ ctx.save(); ctx.translate(b.x + b.w/2, b.y + b.h/2); ctx.fillStyle = (b.owner==='player')? (b.pierce?'#9cff7a':'#ffd166') : (b.owner==='boss' ? '#ff3b7a' : '#ff6b6b'); ctx.fillRect(-b.w/2, -b.h/2, b.w, b.h); ctx.restore(); }
  function drawItem(it){ ctx.save(); ctx.translate(it.x, it.y); ctx.fillStyle='rgba(255,255,255,.15)'; ctx.beginPath(); ctx.arc(0,0, 10*DPR, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = it.type==='SPREAD' ? '#ffd166' : it.type==='PIERCE' ? '#9cff7a' : '#67b8ff'; ctx.strokeStyle='rgba(255,255,255,.3)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.arc(0,0, 7*DPR, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#0b0f19'; ctx.font = `${8*DPR}px ui-sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(it.type[0], 0, 0); ctx.restore(); }

  // Pointer: 드래그 = 이동 + 자동사격
  canvas.addEventListener('pointerdown', (e)=>{ dragActive = true; keys.fire = true; ensureAudio(); });
  window.addEventListener('pointerup', ()=>{ dragActive = false; keys.fire = false; });
  window.addEventListener('pointermove', (e)=>{ if(!dragActive) return; const rect = canvas.getBoundingClientRect(); const x = (e.clientX - rect.left) * DPR; player.x = clamp(x, 14*DPR, playW - 14*DPR); }, {passive:false});

  // Keyboard (desktop)
  window.addEventListener('keydown', (e)=>{ if(e.code==='ArrowLeft' || e.code==='KeyA') { keys.left=true; } if(e.code==='ArrowRight' || e.code==='KeyD') { keys.right=true; } if(e.code==='Space') { keys.fire=true; e.preventDefault(); } if(e.code==='KeyP') togglePause(); if(e.code==='Enter' && document.activeElement===homeLogo) goHome(); });
  window.addEventListener('keyup', (e)=>{ if(e.code==='ArrowLeft' || e.code==='KeyA') { keys.left=false; } if(e.code==='ArrowRight' || e.code==='KeyD') { keys.right=false; } if(e.code==='Space') { keys.fire=false; } });

  function togglePause(){ if(!game.started||game.over) return; game.paused = !game.paused; updatePauseButtons(); if(!game.paused) ensureAudio(); }
  function toggleMute(){ game.muted = !game.muted; elMute.textContent = game.muted? '🔇 음소거' : '🔊 사운드'; if(!game.muted) ensureAudio(); }
  function goHome(){ // 초기 화면으로 이동
    game.paused = true; updatePauseButtons(); showOverlay(startOverlay);
  }
  if(elPause) elPause.addEventListener('click', togglePause);
  if(headerPause) headerPause.addEventListener('click', togglePause);
  if(homeLogo){ homeLogo.addEventListener('click', goHome); homeLogo.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); goHome(); } }); }
  elMute.addEventListener('click', toggleMute);

  startBtn.addEventListener('click', ()=>{ ensureAudio(); startGame(); });
  retryBtn.addEventListener('click', ()=>{ hideOverlay(gameOverOverlay); ensureAudio(); startGame(); });

  window.addEventListener('resize', resize); resize();
  buildWave(1); player.x = playW * 0.5; player.y = playH - 36 * DPR; refreshLives(); updatePauseButtons();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>