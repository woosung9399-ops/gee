<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>모바일 갤러그</title>
<meta name="description" content="모바일 최적화 갤러그. 드래그=이동+사격, 8방향 이동, 보스 강화, 아이템, 다양한 탄막 패턴" />

<!-- 🔸 Favicon -->
<link rel="icon" href="favicon.ico" sizes="any">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
<link rel="icon" type="image/png" sizes="192x192" href="favicon-192.png">
<link rel="apple-touch-icon" sizes="180x180" href="favicon-180.png">

<style>
  :root{
    --bg:#0b0f19; --panel:#12182A; --accent:#67b8ff; --accent2:#ffd166;
    --danger:#ff6b6b; --text:#e9ecff; --muted:#9aa5c4; --border:#223057;
    --shadow:rgba(0,0,0,.35); --header-h: 64px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;}
  body{
    margin:0;
    background:radial-gradient(1200px 600px at 50% -10%, #0f1530 0%, #0b0f19 45%, #090d16 100%);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Pretendard","Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    touch-action:none; overscroll-behavior:none; font-size:12px
  }

  /* Header (white) */
  header{
    position:fixed; top:0; left:0; right:0; z-index:50;
    padding: calc(env(safe-area-inset-top, 0px) + 8px) 10px 8px 10px;
    display:flex; justify-content:space-between; align-items:center; gap:8px; pointer-events:auto;
    background:#fff; color:#111;
    border-bottom:1px solid #e5e7eb;
    box-shadow:0 6px 20px rgba(0,0,0,.05);
  }
  header .logo{display:inline-flex; align-items:center; gap:8px; cursor:pointer; background:#fff; border:0; border-radius:10px; padding:4px 6px;}
  header .logo img{display:block; height:24px; max-height:32px; width:auto; object-fit:contain; image-rendering:auto}
  header .hud{display:flex; gap:6px; align-items:center;}
  .btn{background:#fff; color:#111; border:1px solid #e5e7eb; border-radius:10px; padding:6px 10px; box-shadow:0 2px 10px rgba(0,0,0,.04); font-weight:700; cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  /* Layout: header-separated play area */
  .wrap{position:relative; width:100%; height:100dvh;}
  canvas{
    position:fixed; left:0; right:0; bottom:0; top:var(--header-h);
    width:100%; height:calc(100dvh - var(--header-h)); display:block;
  }

  /* HUD (minimal & non-intrusive) */
  .hud-layer{
    position:fixed; left:0; right:0; top:var(--header-h); bottom:0; pointer-events:none;
  }
  .topbar{
    position:absolute; top:6px; left:8px; right:8px;
    display:flex; flex-direction:column; align-items:flex-start; gap:4px;
    pointer-events:none;
  }
  /* ⚠️ 가림 방지: 배경/테두리 제거, 작은 글씨, 텍스트 그림자만 */
  .pill{
    background:transparent; border:0; padding:0;
    font-weight:800; font-size:11px; line-height:1.1;
    color:#eaf2ff; text-shadow:0 1px 2px rgba(0,0,0,.6);
  }
  .lives{display:inline-flex; gap:3px; margin-top:2px}
  .ship{width:14px; height:10px; background:linear-gradient(#9be7ff,#67b8ff);
    clip-path:polygon(50% 0%, 65% 30%, 100% 35%, 100% 65%, 65% 70%, 50% 100%, 35% 70%, 0% 65%, 0% 35%, 35% 30%);
    filter:drop-shadow(0 0 4px rgba(103,184,255,.45));}

  /* Overlays */
  .overlay{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;}
  .card{background:rgba(10,14,26,.85); border:1px solid var(--border); border-radius:16px; padding:16px; width:min(520px, calc(100% - 24px)); box-shadow:0 20px 60px var(--shadow); text-align:center}
  .card h1{margin:0 0 6px; font-size:16px}
  .card p{margin:6px 0; color:var(--muted); font-size:12px}
  .card .row{display:flex; gap:6px; justify-content:center; margin-top:8px; flex-wrap:wrap}
  .card .chip{background:rgba(255,255,255,.06); border:1px solid var(--border); border-radius:999px; padding:6px 8px; font-weight:600; font-size:11px}
  .startbtn{margin-top:10px; background:rgba(18,24,42,.75); border:1px solid var(--border); border-radius:12px; padding:8px 10px; font-weight:700}

  /* Footer */
  .site-footer{
    position:fixed; left:0; right:0; bottom:0; z-index:40; pointer-events:none;
    display:flex; justify-content:center; align-items:center;
    padding:6px; font-size:11px; color:var(--muted);
    text-shadow:0 1px 2px rgba(0,0,0,.35);
  }
  .site-footer .foot-pill{background:rgba(18,24,42,.55); border:1px solid var(--border); border-radius:999px; padding:4px 10px;}
</style>
</head>
<body>

  <!-- Header (white) -->
  <header id="mainHeader">
    <div id="homeLogo" class="logo" role="button" tabindex="0" title="초기 화면으로 이동">
      <img id="logoImg" src="https://api.multicampus.com/ssf/v1/resource/public/images/FILBS202506207041267" alt="multicampus" decoding="async" loading="lazy" />
    </div>
    <div class="hud" aria-live="polite">
      <button id="pauseBtnTop" class="btn">⏸️ Pause</button>
      <button id="muteBtnTop" class="btn">🔇 Mute</button>
      <button id="restartBtnTop" class="btn" title="게임 재시작">🔄 Restart</button>
    </div>
  </header>

  <div class="wrap">
    <canvas id="game"></canvas>

    <!-- HUD: 점수/스테이지/라이프만, 투명 텍스트 -->
    <div class="hud-layer">
      <div class="topbar">
        <div class="pill">🏆 점수 <span id="score">0</span></div>
        <div class="pill">🗺️ 스테이지 <span id="stage">1</span> / <span id="maxstage">10</span></div>
        <div class="pill lives" id="lives"></div>
      </div>
    </div>

    <div class="overlay" id="startOverlay">
      <div class="card">
        <h1>👾 모바일 갤러그</h1>
        <p>화면을 <b>드래그</b>하면 <b>8방향 이동 + 자동사격</b><br/>보스는 HP 400부터 시작, 스테이지마다 150 증가</p>
        <div class="row">
          <div class="chip">📱 모바일 최적화</div>
          <div class="chip">🔥 드래그 연사</div>
          <div class="chip">👑 보스 강화</div>
          <div class="chip">🧰 무기 아이템</div>
        </div>
        <div class="startbtn" id="startBtn">탭하여 시작</div>
      </div>
    </div>

    <div class="overlay" id="gameOverOverlay" style="display:none">
      <div class="card">
        <h1 id="overTitle">게임 오버 💫</h1>
        <p>점수: <b id="finalScore">0</b> | 최고: <b id="finalHi">0</b></p>
        <div class="startbtn" id="retryBtn">다시 시작</div>
      </div>
    </div>
  </div>

  <footer class="site-footer" aria-label="사이트 푸터"><div class="foot-pill">© multicampus arcade</div></footer>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const $ = id => document.getElementById(id);

  // Header controls
  const headerEl = $('mainHeader');
  const headerPause = $('pauseBtnTop');
  const headerMute = $('muteBtnTop');
  const headerRestart = $('restartBtnTop');
  const homeLogo = $('homeLogo');

  // Minimal HUD
  const elScore = $('score');
  const elStage = $('stage');
  const elMaxStage = $('maxstage');
  const elLives = $('lives');

  // Overlays
  const startOverlay = $('startOverlay');
  const gameOverOverlay = $('gameOverOverlay');
  const overTitle = $('overTitle');
  const finalScore = $('finalScore');
  const finalHi = $('finalHi');
  const startBtn = $('startBtn');
  const retryBtn = $('retryBtn');

  // DPR & layout
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  const maxStage = 10; elMaxStage.textContent = maxStage;
  let playW = 0, playH = 0;
  const margin = ()=>14*DPR;

  function resize() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    const headerH = headerEl ? headerEl.getBoundingClientRect().height : 0;
    const w = window.innerWidth, h = Math.max(0, window.innerHeight - headerH);
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    playW = canvas.width; playH = canvas.height;
    if(!game.started){
      player.x = playW * 0.5;
      player.y = playH - Math.max(60*DPR, playH*0.2);
    } else {
      player.x = clamp(player.x, margin(), playW - margin());
      player.y = clamp(player.y, margin(), playH - margin());
    }
    document.documentElement.style.setProperty('--header-h', `${Math.round(headerH)}px`);
  }

  // Game state
  const game = { started:false, paused:false, muted:true, over:false, score:0, stage:1, lives:3, hi:Number(localStorage.getItem('galaga_hi')||0), inBoss:false, victory:false };

  // Player (크게): ⬆️
  const player = { x: 200, y: 0, w: 32, h: 22, speed: 280, cooldown:0, baseDelay:0.11, fireDelay:0.11, invul:0, blink:0 };
  const weapon = { type:'NORMAL', timer:0 };

  // Entities
  const bullets = []; // {x,y,vx,vy,owner:'player'|'enemy'|'boss', w,h, ...}
  let enemies = [];   // {x,y,w,h,alive,row,col}
  let enemyBox = {x:0,y:0,w:0,h:0, dir:1, speed:40, step:16};
  let lastEnemyShot = 0; let boss = null; // {x,y,w,h,hp,maxHp,dir,speed,phase,shotTimer,angle}
  const items = []; // {x,y,w,h,vy,type}

  // Input (8-way)
  const keys = {left:false, right:false, up:false, down:false, fire:false};
  let dragActive = false;

  // Audio
  const AudioCtx = window.AudioContext || window.webkitAudioContext; let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) try{ audioCtx = new AudioCtx(); }catch(e){} }
  function beep(freq=420, dur=0.05, vol=0.05){ if(game.muted) return; ensureAudio(); if(!audioCtx) return; const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(audioCtx.destination); o.start(); o.stop(t+dur); }

  // Helpers
  const rand = (a,b)=>Math.random()*(b-a)+a; const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  const aimVec = (sx,sy, tx,ty, spd)=>{ const dx=tx-sx, dy=ty-sy; const d=Math.hypot(dx,dy)||1; return {vx:dx/d*spd, vy:dy/d*spd}; };

  function refreshLives(){ elLives.innerHTML = ''; for(let i=0;i<game.lives;i++){ const d=document.createElement('div'); d.className='ship'; elLives.appendChild(d);} }
  function resetHUD(){ elScore.textContent = game.score; elStage.textContent = game.stage; refreshLives(); }

  // Wave build (적 크기 축소): ⬇️
  function buildWave(stage=1){
    enemies.length = 0; boss = null; game.inBoss = false;
    const rows = clamp(3 + Math.floor(stage*0.6), 3, 7);
    const cols = clamp(6 + Math.floor(stage/2), 6, 12);
    const cellW = 30 * DPR, cellH = 26 * DPR; // spacing 조금 촘촘
    const startX = (playW - cols*cellW) * 0.5; const startY = 26 * DPR;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        // 기존 24x18에서 ↓ 줄임 (적 작게)
        enemies.push({ x: startX + c*cellW, y: startY + r*cellH, w: 20*DPR, h: 15*DPR, alive:true, row:r, col:c });
      }
    }
    enemyBox = { x:startX, y:startY, w: cols*cellW, h: rows*cellH, dir:1, speed: (40 + stage*14) * DPR, step: 16*DPR };
  }

  function spawnBoss(stage){
    // HP: 1스테이지 400, 스테이지마다 +150
    const hp = 400 + (stage - 1) * 150;
    const size = Math.min(120 + stage*10, 200) * DPR;
    const speed = (40 + stage*10) * DPR; // 이동속도 강화
    boss = { x: playW*0.5 - size*0.5, y: 36*DPR, w: size, h: size*0.6, hp, maxHp: hp, dir: 1, speed, phase: 0, shotTimer: 0, angle: 0 };
    game.inBoss = true; beep(200,0.25,0.07); beep(160,0.25,0.06);
  }

  function startGame(){ game.started = true; game.paused=false; game.over=false; game.victory=false; game.score=0; game.stage=1; game.lives=3; player.invul=1.3; player.blink=0; weapon.type='NORMAL'; weapon.timer=0; player.fireDelay = player.baseDelay; resetHUD(); buildWave(game.stage); player.x = playW * 0.5; player.y = playH - Math.max(60*DPR, playH*0.2); bullets.length = 0; items.length = 0; hideOverlay(startOverlay); }
  function nextStage(){ if(game.stage >= maxStage){ victory(); return; } game.stage++; elStage.textContent = game.stage; game.inBoss=false; boss=null; buildWave(game.stage); player.invul=1.0; player.blink=0; }
  function victory(){ game.victory = true; game.over=true; game.paused=true; overTitle.textContent = '모든 난이도 클리어! 🏆'; finalScore.textContent = game.score; if(game.score > (game.hi||0)){ game.hi = game.score; localStorage.setItem('galaga_hi', String(game.hi)); } finalHi.textContent = game.hi||0; showOverlay(gameOverOverlay); }
  function gameOver(){ game.over = true; game.paused = true; overTitle.textContent = '게임 오버 💫'; finalScore.textContent = game.score; const prevHi = Number(localStorage.getItem('galaga_hi')||0); if(game.score > prevHi){ localStorage.setItem('galaga_hi', String(game.score)); } finalHi.textContent = Math.max(prevHi, game.score); showOverlay(gameOverOverlay); }
  function showOverlay(el){ el.style.display='flex'; } function hideOverlay(el){ el.style.display='none'; }

  // Weapons & Items (HUD 표시는 제거, 기능만 유지)
  function grantWeapon(type){
    weapon.type = type; weapon.timer = 15;
    if(type==='RAPID') player.fireDelay = Math.max(0.05, player.baseDelay*0.6); else player.fireDelay = player.baseDelay;
    beep(900,0.08,0.05); beep(600,0.08,0.05);
  }
  function maybeDropItem(x,y){
    const chance = 0.12;
    if(Math.random() < chance){
      const types = ['SPREAD','PIERCE','RAPID'];
      const t = types[(Math.random()*types.length)|0];
      items.push({x:x, y:y, w:14*DPR, h:14*DPR, vy: 120*DPR, type:t}); // 떨어지는 속도↑
    }
  }

  function attemptShoot(){
    if(player.cooldown>0) return;
    const baseVy = -540*DPR;
    const bw = 3*DPR, bh = 10*DPR;
    const make = (offX, offVyMul=1)=> bullets.push({x:player.x + offX - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:0, vy:baseVy*offVyMul, owner:'player', pierce:(weapon.type==='PIERCE')});
    if(weapon.type==='SPREAD'){
      bullets.push({x:player.x - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:-120*DPR, vy:baseVy*0.95, owner:'player', pierce:false});
      make(0,1);
      bullets.push({x:player.x - bw*0.5, y:player.y - player.h, w:bw, h:bh, vx:120*DPR, vy:baseVy*0.95, owner:'player', pierce:false});
    } else { make(0,1); }
    player.cooldown = player.fireDelay; beep(880,0.04,0.04);
  }

  // Enemy shots: 아래로만 + 다양한 패턴
  function enemyShoot(from){
    const s = game.stage;
    const base = (230 + s*38) * DPR;
    const pattern = Math.floor(Math.random()*5);
    const originX = from.x + from.w*0.5, originY = from.y + from.h;

    if(pattern===0){
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base, owner:'enemy'});
    } else if(pattern===1){
      const drift = (Math.random()<0.5?-1:1) * (40 + s*4) * DPR;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:drift*0.3, vy:base, owner:'enemy'});
    } else if(pattern===2){
      const vx = (Math.random()<0.5?-1:1) * (80 + s*6) * DPR;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx, vy:base*0.9, owner:'enemy', zig:1});
    } else if(pattern===3){
      const amp = (60 + s*6) * DPR;
      const freq = 1.6 + s*0.06;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base*0.92, owner:'enemy', wave:{amp, freq, t:0}});
    } else {
      const grav = (200 + s*30) * DPR;
      bullets.push({x:originX, y:originY, w:4*DPR, h:10*DPR, vx:0, vy:base*0.75, owner:'enemy', grav});
    }
    beep(260,0.06,0.035);
  }

  // Boss patterns (강화된 탄막/속도)
  function bossShoot(){
    if(!boss) return;
    const s = game.stage;
    const cx = boss.x + boss.w*0.5; const cy = boss.y + boss.h*0.5;
    boss.angle += 0.25 + s*0.03;
    const pick = (s % 4);
    const speedBase = (250 + s*45) * DPR;

    switch(pick){
      case 1: // spiral
        for(let k=0;k<5;k++){
          const ang = (boss.angle + k*0.5);
          const vx = Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase;
          bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});
        }
        break;
      case 2: // 조준 벌스트
        for(let i=0;i<4+Math.floor(s*0.4);i++){
          const spread = (-0.2 + (i/Math.max(1,3+Math.floor(s*0.4)))*0.4);
          const V = aimVec(cx, cy, player.x, player.y, speedBase);
          const vx = V.vx + Math.sin(spread)*100*DPR;
          const vy = V.vy + Math.cos(spread)*60*DPR;
          bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});
        }
        break;
      case 3: // 스윕 아크
        for(let a=-0.6;a<=0.6;a+=0.1){
          const ang = a + Math.sin(boss.angle*0.6)*0.5;
          const vx=Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase;
          bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});
        }
        break;
      default: // 링
        const n = 12 + Math.floor(s*0.6);
        for(let i=0;i<n;i++){
          const ang = (i/n)*Math.PI*2;
          const vx=Math.sin(ang)*speedBase, vy=Math.cos(ang)*speedBase;
          bullets.push({x:cx, y:cy, w:4*DPR, h:10*DPR, vx, vy, owner:'boss'});
        }
    }
    beep(180,0.08,0.05);
  }

  function killEnemy(e, worldX, worldY){ e.alive=false; game.score += 10 + Math.floor((8 - e.row) * 0.5); elScore.textContent = game.score; maybeDropItem(worldX, worldY); beep(520,0.05,0.05); }
  function hitPlayer(){ if(player.invul>0) return; game.lives--; refreshLives(); if(game.lives<=0){ gameOver(); return; } player.invul = 1.6; player.blink = 0; beep(120,0.18,0.04); for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if(b.owner!=='player' && b.y>player.y-60*DPR) bullets.splice(i,1); } }

  // Loop
  let last = 0; function loop(ts){ if(!last) last = ts; const dt = Math.min(0.033, (ts - last)/1000); last = ts; if(game.started && !game.paused){ update(dt); render(); } else { render(); } requestAnimationFrame(loop); }

  function update(dt){
    // weapon timer
    if(weapon.timer>0){ weapon.timer -= dt; if(weapon.timer<=0){ weapon.timer=0; weapon.type='NORMAL'; player.fireDelay=player.baseDelay; } }

    // 8-way movement (normalized)
    let dirX = 0, dirY = 0;
    if(keys.left) dirX -= 1; if(keys.right) dirX += 1;
    if(keys.up) dirY -= 1; if(keys.down) dirY += 1;
    const mag = Math.hypot(dirX, dirY) || 1;
    player.x += (dirX / mag) * player.speed * DPR * dt;
    player.y += (dirY / mag) * player.speed * DPR * dt;

    // bounds
    player.x = clamp(player.x, margin(), playW - margin());
    player.y = clamp(player.y, margin(), playH - margin());

    // firing
    if(keys.fire) attemptShoot();
    if(player.cooldown>0) player.cooldown -= dt;
    if(player.invul>0){ player.invul -= dt; player.blink += dt*10; }

    // enemies/boss
    if(game.inBoss && boss){
      boss.x += boss.speed * boss.dir * dt;
      if(boss.x < 8*DPR || boss.x + boss.w > playW - 8*DPR){ boss.dir *= -1; boss.y += 8*DPR; boss.speed *= 1.01; }
      boss.shotTimer += dt; const baseInt = Math.max(0.18, 0.9 - game.stage*0.07);
      if(boss.shotTimer > baseInt){ boss.shotTimer = 0; bossShoot(); }
    } else {
      if(enemies.some(e=>e.alive)){
        enemyBox.x += enemyBox.speed * enemyBox.dir * dt;
        const alive = enemies.filter(e=>e.alive);
        let minX = Infinity, maxX = -Infinity, maxY = -Infinity; const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0;
        for(const e of alive){ const ex = e.x + (enemyBox.x - baseX); const ey = e.y + (enemyBox.y - baseY); minX = Math.min(minX, ex); maxX = Math.max(maxX, ex + e.w); maxY = Math.max(maxY, ey + e.h); }
        if(minX < 8*DPR || maxX > playW - 8*DPR){ enemyBox.dir *= -1; enemyBox.y += enemyBox.step; enemyBox.speed *= 1.02; }
        if(maxY > player.y - 10*DPR){ hitPlayer(); enemyBox.y -= 24*DPR; }
        lastEnemyShot += dt; const interval = Math.max(0.33, 1.0 - game.stage*0.06);
        if(lastEnemyShot > interval){
          lastEnemyShot = 0;
          const bottomers = alive.filter(e=> !alive.some(o=>o.col===e.col && o.row>e.row));
          if(bottomers.length){
            const shooter = bottomers[(Math.random()*bottomers.length)|0];
            const baseX2 = enemies[0] ? enemies[0].x : 0; const baseY2 = enemies[0] ? enemies[0].y : 0;
            enemyShoot({x: shooter.x + (enemyBox.x - baseX2), y: shooter.y + (enemyBox.y - baseY2), w: shooter.w, h: shooter.h});
          }
        }
      } else { if(!game.inBoss && !boss){ spawnBoss(game.stage); } }
    }

    // bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(b.owner==='enemy'){
        if(b.zig){ b.vx += (Math.random()<0.5?-1:1)*10*DPR*dt; }
        if(b.wave){ b.wave.t += dt; b.vx = Math.sin(b.wave.t * b.wave.freq) * b.wave.amp; }
        if(b.grav){ b.vy += b.grav * dt; }
        if(b.vy < 0) b.vy = Math.abs(b.vy);
      }
      b.x += b.vx*dt; b.y += b.vy*dt;
      if(b.y < -60*DPR || b.y > playH + 60*DPR || b.x < -60*DPR || b.x > playW + 60*DPR) bullets.splice(i,1);
    }

    // items
    for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.y += it.vy*dt; if(it.y>playH+20*DPR){ items.splice(i,1); continue; } const P={x:player.x - player.w*0.5, y:player.y - player.h*0.5, w:player.w, h:player.h}; if(aabb(it,P)){ grantWeapon(it.type); items.splice(i,1); }}

    // collisions: player bullets vs enemies/boss
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i]; if(b.owner!=='player') continue; let removed=false;
      if(game.inBoss && boss){
        const B = {x:boss.x, y:boss.y, w:boss.w, h:boss.h};
        if(aabb(b,B)){
          if(!(weapon.type==='PIERCE')){ bullets.splice(i,1); removed=true; }
          boss.hp -= 8 + Math.floor(game.stage*0.5);
          beep(380,0.05,0.04);
          if(boss.hp<=0){
            game.score += 250 + game.stage*60; elScore.textContent = game.score;
            boss=null; game.inBoss=false; nextStage();
          }
        }
      }
      if(removed) continue;
      for(let j=0;j<enemies.length;j++){
        const e=enemies[j]; if(!e.alive) continue;
        const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0;
        const ex = e.x + (enemyBox.x - baseX); const ey = e.y + (enemyBox.y - baseY);
        const E = {x:ex,y:ey,w:e.w,h:e.h};
        if(aabb(b,E)){
          if(!(weapon.type==='PIERCE')){ bullets.splice(i,1); removed=true; }
          killEnemy(e, ex+e.w*0.5, ey+e.h*0.5);
          break;
        }
      }
    }

    // collisions: enemy/boss bullets vs player
    const P = {x:player.x - player.w*0.5, y:player.y - player.h*0.5, w:player.w, h:player.h};
    for(let i=bullets.length-1;i>=0;i--){ const b=bullets[i]; if(b.owner!=='player' && aabb(b,P)){ bullets.splice(i,1); hitPlayer(); } }
  }

  function render(){
    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawStars();
    if(!game.over){ if(!(player.invul>0 && Math.floor(player.blink)%2===0)){ drawShip(player.x, player.y, player.w, player.h); } }
    for(const e of enemies){ if(!e.alive) continue; const baseX = enemies[0] ? enemies[0].x : 0; const baseY = enemies[0] ? enemies[0].y : 0; drawEnemy(e.x + (enemyBox.x - baseX), e.y + (enemyBox.y - baseY), e.w, e.h, e.row); }
    if(game.inBoss && boss){ drawBoss(boss); }
    for(const b of bullets){ drawBullet(b); }
    for(const it of items){ drawItem(it); }
    ctx.restore();
  }

  // Visuals
  const starField = new Array(120).fill(0).map(()=>({x:Math.random(), y:Math.random(), z:Math.random()*0.8+0.2}));
  function drawStars(){ const w=canvas.width, h=canvas.height; for(const s of starField){ s.y += 0.06 * s.z; if(s.y>1) s.y -= 1; const x=s.x*w, y=s.y*h; const r = (0.6 + 1.4*s.z) * DPR; ctx.fillStyle=`rgba(255,255,255,${0.33 + 0.42*s.z})`; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } }

  // Player ship (크게)
  function drawShip(cx, cy, w, h){ ctx.save(); ctx.translate(cx, cy); const g = ctx.createLinearGradient(0,-h/2, 0, h/2); g.addColorStop(0,'#a8ecff'); g.addColorStop(1,'#67b8ff'); ctx.fillStyle = g; ctx.strokeStyle='rgba(255,255,255,.2)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.lineTo(w*0.35, -h*0.1); ctx.lineTo(w*0.5, h*0.05); ctx.lineTo(w*0.5, h*0.35); ctx.lineTo(0, h/2); ctx.lineTo(-w*0.5, h*0.35); ctx.lineTo(-w*0.5, h*0.05); ctx.lineTo(-w*0.35, -h*0.1); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#e6f7ff'; ctx.fillRect(-w*0.15, -h*0.15, w*0.3, h*0.18); ctx.restore(); }

  // Enemy (작게)
  function drawEnemy(x,y,w,h,row){ ctx.save(); ctx.translate(x+w/2, y+h/2); const hues = [200, 270, 130, 10, 320, 40, 160, 220]; const hue = hues[row % hues.length]; ctx.fillStyle = `hsl(${hue} 80% 60%)`; ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.moveTo(0, -h*0.45); ctx.lineTo(w*0.5, -h*0.15); ctx.lineTo(w*0.48, h*0.15); ctx.lineTo(0, h*0.45); ctx.lineTo(-w*0.48, h*0.15); ctx.lineTo(-w*0.5, -h*0.15); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(0,0, h*0.16, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0, h*0.08, 0, Math.PI*2); ctx.fill(); ctx.restore(); }

  function drawBoss(b){ ctx.save(); ctx.translate(b.x + b.w/2, b.y + b.h/2); const hue = 30 + game.stage*30; ctx.fillStyle = `hsl(${hue} 85% 55%)`; ctx.strokeStyle='rgba(0,0,0,.3)'; ctx.lineWidth=2*DPR; const w=b.w, h=b.h; ctx.beginPath(); ctx.moveTo(0,-h*0.5); ctx.quadraticCurveTo(w*0.45,-h*0.2, w*0.5, 0); ctx.quadraticCurveTo(w*0.45,h*0.2, 0, h*0.5); ctx.quadraticCurveTo(-w*0.45,h*0.2, -w*0.5, 0); ctx.quadraticCurveTo(-w*0.45,-h*0.2, 0,-h*0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0, Math.min(w,h)*0.12, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0, Math.min(w,h)*0.06, 0, Math.PI*2); ctx.fill(); ctx.restore(); }

  function drawBullet(b){ ctx.save(); ctx.translate(b.x + b.w/2, b.y + b.h/2); ctx.fillStyle = (b.owner==='player')? (weapon.type==='PIERCE'?'#9cff7a':'#ffd166') : (b.owner==='boss' ? '#ff3b7a' : '#ff6b6b'); ctx.fillRect(-b.w/2, -b.h/2, b.w, b.h); ctx.restore(); }
  function drawItem(it){ ctx.save(); ctx.translate(it.x, it.y); ctx.fillStyle='rgba(255,255,255,.15)'; ctx.beginPath(); ctx.arc(0,0, 10*DPR, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = it.type==='SPREAD' ? '#ffd166' : it.type==='PIERCE' ? '#9cff7a' : '#67b8ff'; ctx.strokeStyle='rgba(255,255,255,.3)'; ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.arc(0,0, 7*DPR, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#0b0f19'; ctx.font = `${8*DPR}px ui-sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(it.type[0], 0, 0); ctx.restore(); }

  // Pointer: drag = move (X+Y) + autofire
  canvas.addEventListener('pointerdown', (e)=>{
    dragActive = true; keys.fire = true; ensureAudio();
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top) * DPR;
    player.x = clamp(x, margin(), playW - margin());
    player.y = clamp(y, margin(), playH - margin());
  });
  window.addEventListener('pointerup', ()=>{ dragActive = false; keys.fire = false; });
  window.addEventListener('pointermove', (e)=>{
    if(!dragActive) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top) * DPR;
    player.x = clamp(x, margin(), playW - margin());
    player.y = clamp(y, margin(), playH - margin());
  }, {passive:false});

  // Keyboard (desktop): 8방향 + fire
  window.addEventListener('keydown', (e)=>{
    if(e.code==='ArrowLeft' || e.code==='KeyA') keys.left=true;
    if(e.code==='ArrowRight' || e.code==='KeyD') keys.right=true;
    if(e.code==='ArrowUp' || e.code==='KeyW') keys.up=true;
    if(e.code==='ArrowDown' || e.code==='KeyS') keys.down=true;
    if(e.code==='Space'){ keys.fire=true; e.preventDefault(); }
    if(e.code==='KeyP') togglePause();
    if(e.code==='Enter' && document.activeElement===homeLogo) goHome();
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code==='ArrowLeft' || e.code==='KeyA') keys.left=false;
    if(e.code==='ArrowRight' || e.code==='KeyD') keys.right=false;
    if(e.code==='ArrowUp' || e.code==='KeyW') keys.up=false;
    if(e.code==='ArrowDown' || e.code==='KeyS') keys.down=false;
    if(e.code==='Space') keys.fire=false;
  });

  function togglePause(){ if(!game.started||game.over) return; game.paused = !game.paused; if(!game.paused) ensureAudio(); }
  function toggleMute(){ game.muted = !game.muted; if(!game.muted) ensureAudio(); }
  function goHome(){ game.paused = true; showOverlay(startOverlay); }

  // Header actions
  if(headerPause) headerPause.addEventListener('click', togglePause);
  if(headerMute) headerMute.addEventListener('click', toggleMute);
  if(headerRestart) headerRestart.addEventListener('click', ()=>{ hideOverlay(gameOverOverlay); ensureAudio(); startGame(); });
  if(homeLogo){
    homeLogo.addEventListener('click', goHome);
    homeLogo.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); goHome(); } });
  }

  startBtn.addEventListener('click', ()=>{ ensureAudio(); startGame(); });
  retryBtn.addEventListener('click', ()=>{ hideOverlay(gameOverOverlay); ensureAudio(); startGame(); });

  window.addEventListener('resize', resize); resize();
  buildWave(1); refreshLives(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>